#! /bin/bash
# generated by collect_git_remote_add_recursively.sh

pushd $(dirname $0)                                                             2> /dev/null   > /dev/null
cd ..

mode="d"
debug=

getopts ":fFDqh" opt
#echo opt+arg = "$opt$OPTARG"
case "$opt$OPTARG" in
f )
  echo "--- check out master/HEAD before registering all git remotes ---"
  for (( i=OPTIND; i > 1; i-- )) do
    shift
  done
  #echo args: $@
  mode="f"

  git submodule sync
  git submodule update --init
  git submodule update --init --recursive

  tools/git_checkout_submodules_head.sh
  ;;

F )
  for (( i=OPTIND; i > 1; i-- )) do
    shift
  done
  mode="f"
  ;;

D )
  for (( i=OPTIND; i > 1; i-- )) do
    shift
  done
  debug="T"
  ;;

"?" )
  echo "--- set up git remotes only ---"
  ;;

q )
  echo "--- set up git remotes only ---"
  for (( i=OPTIND; i > 1; i-- )) do
    shift
  done
  #echo args: $@
  mode="q"
  ;;

* )
  cat <<EOT
$0 [-f] [-q] [submodule-paths]

set up git remotes for any / all submodules.

-f       : 'full featured', i.e. check out the preferred branch for each submodule
           and register all submodule remotes. Also makes sure all submodules have
           been properly initialized.
-F       : same as '-f' WITHOUT the 'git submodule' initializations. Use this option
           when you only want to fully set/refresh the remotes for already present
           submodules.
-D       : DEBUG: print extensive debug / progress information.           
-q       : 'quick', i.e. only register all submodule remotes which have not been
           set up yet.

Default behaviour is 'quick mode'.

submodule-paths
         : when you specify one or more submodule directories, than only the
           remotes for those submodules will be set up.
           This is optional; the default sets up the remotes for ALL submodules.

EOT
  exit
  ;;
esac


submodule=xxxxxx

# args: (path, name, repo, argc, argv...)
function register_remote {
    argc=$#
    argv=("$@")
    path=$1
    name=$2
    repo=$3
    if [ $debug ] ; then echo "register_remote [$path] [$name] [$repo] [$argc] [...]"; fi

    # only when paths have been specified on the commandline do we check whether the given remote should be registered
    # (apart from the separate check to see if the submodule has actually been installed, see further below)
    if test $argc -gt 4 ; then
        hit=0
        for ((i=4; i < $argc; i++)); do
            #echo testing dir $i: ${argv[$i]}
            if test ${argv[$i]} = $path ; then
                hit=1
                break
            fi
        done
    else
        hit=1
    fi

    if [ $debug ] ; then echo "TEST HIT = $hit --> $( test $hit -ne 0 ; echo $? )" ; fi
    if test $hit -ne 0 ; then
        if [ $debug ] ; then echo "PATH = $path --> $( test -d $path ; echo $? ), $( test -e $path/.git ; echo $? )"; fi
        if test -d $path && test -e $path/.git ; then
            if [ $debug ] ; then echo "ACTION!"; fi
            if test $submodule != $path ; then
                echo -------------------------------------------------------------------------------------
                echo submodule:: $path
                submodule=$path
            fi
            pushd $path                                                         2> /dev/null   > /dev/null
            if test "$mode" = "f" ; then
                git remote rm $name
            fi
            git remote add $name $repo
            popd                                                                2> /dev/null   > /dev/null
        fi
    fi
}

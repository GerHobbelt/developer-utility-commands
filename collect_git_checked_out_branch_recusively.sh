#! /bin/bash
#
# recursively collect the currently active commit / branch name and
# write them to a shell script for later use on other
# machines (and keeping the info in the destination repository)
#

wd="$( pwd )";

pushd $(dirname $0)                                                                                     2> /dev/null  > /dev/null
utildir="$( pwd )";

# go to root of project
cd ..

wd=$( $utildir/print-git-repo-base-directory.sh "$wd" )
echo "git repository base directory: $wd"
cd "$wd"

if ! test -d "$wd/util" ; then
    mkdir "$wd/util"
fi
dstfile="$wd/util/checkout_to_known_git_branches_recursive.sh"

echo "dstfile: $dstfile"

cat <<EOT

  Executing a RECURSIVE submodule remotes collection.

EOT

ddir=$( dirname "$dstfile" )

usn=$( basename "$dstfile" )

cat > "$dstfile" <<EOT
#! /bin/bash
#
# Generated by the utility: $0 $*
#
# Checkout each git repository to the given branch/commit or list them
#

mode=h;
while getopts ":hlrc" opt ; do
  #echo opt+arg = "\$opt\$OPTARG"
  case "\$opt\$OPTARG" in
  l )
    mode=l;
    ;;

  c )
    mode=c;
    ;;

  r )
    mode=r;
    ;;

  * )
    ;;
  esac
done

if test "\$mode" = "h" ; then
  cat <<EOH
checkout_to_known_git_branches_recursive.sh options

Options:

-h      : print this help
-l      : LIST the branch/commit for each git repository (directory) registered in this script.
-c      : CHECKOUT each git repository to the BRANCH registered in this script.
-r      : CHECKOUT/REVERT each git repository to the COMMIT registered in this script.

Note:

Use the '-r' option to set each repository to an exact commit position, which is useful if,
for instance, you wish to reproduce this registered previous software state (which may
represent a software release) which you wish to analyze/debug.

EOH
  exit 1;
fi

if test "\$mode" = "l" ; then
  cat <<EOH

Git repository directory                    :: commit hash                         / branch name
--------------------------------------------::--------------------------------------------------
EOH
fi



# args: DIR COMMIT [BRANCH]
git_repo_checkout_branch() {
  if test "\$mode" = "c" || test "\$mode" = "r" ; then
    if test -d "\$1" ; then
      pushd "\$1"                                                               2> /dev/null  > /dev/null
      printf "%-43s :: %s / %s\n" "\$1" "\$2" "\$3"
      if test "\$mode" = "c" ; then
        if test -n "\$3" ; then
          # make sure the branch is created locally and is a tracking branch, if it isn't already:
          # https://www.cyberciti.biz/faq/bash-remove-whitespace-from-string/
          current_branch=\$( git branch --show-current )
          if test -z "\$current_branch" -o "\$current_branch" != "\$3" ; then
            git checkout "\$3"
          fi

          shopt -s extglob
          remote_branch=\$( git branch -vv --list \$3 '--format=%(upstream)' )
          # Trim leading whitespaces
          remote_branch="\${remote_branch##*( )}"
          # Trim trailing whitespaces
          remote_branch="\${remote_branch%%*( )}"
          echo "=\${remote_branch}="
          shopt -u extglob

          if test -z "\$remote_branch" ; then
            echo "No remote branch registered for local branch: \$3 --> setting up the remote."
            git branch --track "\$3" "remotes/origin/\$3"                          2> /dev/null  > /dev/null
            git branch --set-upstream-to=remotes/origin/\$3 \$3                    2> /dev/null  > /dev/null
            git checkout "\$3"
          fi
        else
          current_branch=\$( git branch --show-current )
          echo "=\${current_branch}="
          if test -z "\$current_branch" -o "\$current_branch" != "master" ; then
            # checkout to the first of \`master\` or \`main\` in case we're not checked out to either right now:
            if test "\$current_branch" != "main" -a "\$current_branch" != "master" ; then
              echo "Checking out to master/main:"
              git checkout master
              if test \$? -ne 0 ; then
                git checkout main
              fi
            fi
          fi
        fi
      else
        git checkout "\$2"
      fi
      popd                                                                     2> /dev/null  > /dev/null
    fi
  else
    if test -d "\$1" ; then
      printf "%-43s :: %s / %s\n" "\$1" "\$2" "\$3"
    else
      printf "%-43s :: %s / %s\n" "[DIRECTORY DOES NOT EXIST!] \$1" "\$2" "\$3"
    fi
  fi
}


#
# Make sure we switch to the utility directory as all the relative paths for the repositories
# are based off that path!
#
pushd \$(dirname \$0)                                                            2> /dev/null  > /dev/null



#
# The registered repositories:
#

EOT

git submodule foreach --quiet --recursive $@ "$utildir/__collect_git_checked_out_branch_helper__.sh" "$ddir" | sort >> "$dstfile"

cat >> "$dstfile" <<EOT

# --- all done ---

popd                                                                           2> /dev/null  > /dev/null

EOT

popd                                                                                                    2> /dev/null  > /dev/null
